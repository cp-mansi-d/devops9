name: Deploy Lambda

on:
  push:
    branches:
      - main

permissions:
  contents: read

env:
  STAGE_NAME: prod

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Install zip utility
        run: |
          sudo apt-get update
          sudo apt-get install -y zip

      - name: Tidy dependencies
        run: go mod tidy

      - name: Build Linux binary
        run: GOOS=linux GOARCH=amd64 go build -o main main.go

      - name: Create Lambda package
        run: zip function.zip main

      - name: Upload Lambda artifact
        uses: actions/upload-artifact@v4
        with:
          name: lambda-package
          path: function.zip

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Lambda artifact
        uses: actions/download-artifact@v4
        with:
          name: lambda-package

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Upload package to S3 and deploy
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
          ACM_CERTIFICATE_ARN: ${{ secrets.ACM_CERTIFICATE_ARN }}
          CUSTOM_DOMAIN_NAME: ${{ secrets.CUSTOM_DOMAIN_NAME }}
        run: |
          if [ -z "$S3_BUCKET" ]; then
            echo "S3_BUCKET secret is required."
            exit 1
          fi
          
          if [ -z "$ACM_CERTIFICATE_ARN" ]; then
            echo "ACM_CERTIFICATE_ARN secret is required."
            exit 1
          fi
          
          if [ -z "$CUSTOM_DOMAIN_NAME" ]; then
            echo "CUSTOM_DOMAIN_NAME secret is required."
            exit 1
          fi

          S3_FILE_NAME="golang_lambda_${GITHUB_RUN_ID}.zip"
          cp function.zip "$S3_FILE_NAME"
          aws s3 cp "$S3_FILE_NAME" "s3://$S3_BUCKET"

          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name golang-api-stack \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo "NOT_FOUND")

          if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ]; then
            echo "Deleting existing stack in ROLLBACK_COMPLETE state..."
            aws cloudformation delete-stack --stack-name golang-api-stack
            aws cloudformation wait stack-delete-complete --stack-name golang-api-stack
          fi

          # Check and delete existing API Gateway custom domain if it exists
          # This handles conflicts between EDGE and REGIONAL endpoint types
          echo "Checking for existing API Gateway custom domain: $CUSTOM_DOMAIN_NAME"
          
          # Try to get the domain (works for both EDGE and REGIONAL)
          if aws apigateway get-domain-name --domain-name "$CUSTOM_DOMAIN_NAME" >/dev/null 2>&1; then
            echo "Found existing custom domain. Deleting base path mappings first..."
            
            # Delete all base path mappings (required before deleting domain)
            MAX_ATTEMPTS=5
            ATTEMPT=0
            while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
              # Get base path mappings
              MAPPINGS_OUTPUT=$(aws apigateway get-base-path-mappings \
                --domain-name "$CUSTOM_DOMAIN_NAME" \
                --query 'items[*].basePath' \
                --output text 2>/dev/null || echo "")
              
              if [ -z "$MAPPINGS_OUTPUT" ] || [ "$MAPPINGS_OUTPUT" = "None" ]; then
                break
              fi
              
              # Delete each base path mapping
              for base_path in $MAPPINGS_OUTPUT; do
                # Handle empty base path (root path)
                if [ -z "$base_path" ] || [ "$base_path" = "None" ] || [ "$base_path" = "(none)" ]; then
                  # Try deleting with empty string first, then with (none)
                  aws apigateway delete-base-path-mapping \
                    --domain-name "$CUSTOM_DOMAIN_NAME" \
                    --base-path "" 2>/dev/null || \
                  aws apigateway delete-base-path-mapping \
                    --domain-name "$CUSTOM_DOMAIN_NAME" \
                    --base-path "(none)" 2>/dev/null || true
                else
                  echo "Deleting base path mapping: '$base_path'"
                  aws apigateway delete-base-path-mapping \
                    --domain-name "$CUSTOM_DOMAIN_NAME" \
                    --base-path "$base_path" 2>/dev/null || true
                fi
              done
              
              ATTEMPT=$((ATTEMPT + 1))
              sleep 3
            done
            
            echo "Deleting existing custom domain: $CUSTOM_DOMAIN_NAME"
            aws apigateway delete-domain-name --domain-name "$CUSTOM_DOMAIN_NAME" || true
            
            # Wait for domain deletion to complete (can take a few seconds)
            echo "Waiting for domain deletion to complete..."
            sleep 15
            
            # Verify deletion
            if aws apigateway get-domain-name --domain-name "$CUSTOM_DOMAIN_NAME" >/dev/null 2>&1; then
              echo "Warning: Domain still exists after deletion attempt. Waiting longer..."
              sleep 10
            fi
          else
            echo "No existing custom domain found. Proceeding with deployment."
          fi

          aws cloudformation validate-template --template-body file://deployment.yml

          aws cloudformation deploy \
            --stack-name golang-api-stack \
            --template-file deployment.yml \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              S3Key="$S3_FILE_NAME" \
              S3Bucket="$S3_BUCKET" \
              StageName="$STAGE_NAME" \
              AcmCertificateArn="$ACM_CERTIFICATE_ARN" \
              CustomDomainName="$CUSTOM_DOMAIN_NAME" \
              Route53HostedZoneId="${{ secrets.ROUTE53_HOSTED_ZONE_ID }}"


