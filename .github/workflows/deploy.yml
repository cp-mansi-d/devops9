name: Deploy Lambda

on:
  push:
    branches:
      - main

permissions:
  contents: read

env:
  STAGE_NAME: prod
  STACK_NAME: golang-api-stack-new
  LAMBDA_FUNCTION_NAME: GolangGinLambda
  API_GATEWAY_NAME: GolangApi
  LAMBDA_ROLE_NAME: GolangApiLambdaExecutionRole

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Install zip utility
        run: |
          sudo apt-get update
          sudo apt-get install -y zip

      - name: Tidy dependencies
        run: go mod tidy

      - name: Build Linux binary
        run: GOOS=linux GOARCH=amd64 go build -o main main.go

      - name: Create Lambda package
        run: zip function.zip main

      - name: Upload Lambda artifact
        uses: actions/upload-artifact@v4
        with:
          name: lambda-package
          path: function.zip

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Lambda artifact
        uses: actions/download-artifact@v4
        with:
          name: lambda-package

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Upload package to S3 and deploy
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
          CUSTOM_DOMAIN_NAME: ${{ secrets.CUSTOM_DOMAIN_NAME }}
          ACM_CERTIFICATE_ARN: ${{ secrets.ACM_CERTIFICATE_ARN }}
          HOSTED_ZONE_ID: ${{ secrets.HOSTED_ZONE_ID }}
        run: |
          if [ -z "$S3_BUCKET" ]; then
            echo "S3_BUCKET secret is required."
            exit 1
          fi

          S3_FILE_NAME="golang_lambda_${GITHUB_RUN_ID}.zip"
          cp function.zip "$S3_FILE_NAME"
          aws s3 cp "$S3_FILE_NAME" "s3://$S3_BUCKET"

          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null || echo "NOT_FOUND")

          # Handle failed stack states
          if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ] || [ "$STACK_STATUS" = "UPDATE_ROLLBACK_FAILED" ]; then
            echo "Stack is in $STACK_STATUS state. Checking for domain cleanup before deleting stack..."
            
            # Clean up domain if it exists before deleting stack
            if [ -n "$CUSTOM_DOMAIN_NAME" ]; then
              DOMAIN_EXISTS=$(aws apigateway get-domain-name \
                --domain-name "$CUSTOM_DOMAIN_NAME" \
                --query 'domainName' \
                --output text 2>/dev/null || echo "NOT_FOUND")
              
              if [ "$DOMAIN_EXISTS" != "NOT_FOUND" ]; then
                echo "Cleaning up domain before stack deletion..."
                # Delete base path mappings
                BASE_PATHS=$(aws apigateway get-base-path-mappings \
                  --domain-name "$CUSTOM_DOMAIN_NAME" \
                  --query 'items[*].basePath' \
                  --output text 2>/dev/null || echo "")
                
                if [ -n "$BASE_PATHS" ]; then
                  for BASE_PATH in $BASE_PATHS; do
                    if [ "$BASE_PATH" = "(none)" ] || [ -z "$BASE_PATH" ]; then
                      BASE_PATH=""
                    fi
                    echo "  Deleting base path mapping: '$BASE_PATH'"
                    aws apigateway delete-base-path-mapping \
                      --domain-name "$CUSTOM_DOMAIN_NAME" \
                      --base-path "$BASE_PATH" 2>/dev/null || true
                  done
                fi
                
                # Delete the domain
                aws apigateway delete-domain-name \
                  --domain-name "$CUSTOM_DOMAIN_NAME" 2>/dev/null || true
                echo "Domain cleaned up."
                sleep 5
              fi
            fi
            
            echo "Deleting stack in $STACK_STATUS state..."
            aws cloudformation delete-stack --stack-name "$STACK_NAME"
            aws cloudformation wait stack-delete-complete --stack-name "$STACK_NAME" || {
              echo "Stack deletion completed or timed out. Proceeding..."
            }
          fi

          aws cloudformation validate-template --template-body file://deployment.yml

          # Check and handle existing API Gateway domain name BEFORE deployment
          # This is critical to prevent the "Cannot import certificates for EDGE while REGIONAL is active" error
          if [ -n "$CUSTOM_DOMAIN_NAME" ]; then
            echo "Checking for existing API Gateway domain name: $CUSTOM_DOMAIN_NAME"
            
            # Check if domain exists in API Gateway
            EXISTING_DOMAIN=$(aws apigateway get-domain-name \
              --domain-name "$CUSTOM_DOMAIN_NAME" \
              --query 'domainName' \
              --output text 2>/dev/null || echo "NOT_FOUND")
            
            if [ "$EXISTING_DOMAIN" != "NOT_FOUND" ]; then
              echo "Found existing domain name: $CUSTOM_DOMAIN_NAME"
              
              # Get endpoint type FIRST - this is critical
              ENDPOINT_TYPE=$(aws apigateway get-domain-name \
                --domain-name "$CUSTOM_DOMAIN_NAME" \
                --query 'endpointConfiguration.types[0]' \
                --output text 2>/dev/null || echo "UNKNOWN")
              
              echo "Existing domain endpoint type: $ENDPOINT_TYPE"
              
              # Check if it's managed by CloudFormation stack
              STACK_EXISTS=$(aws cloudformation describe-stacks \
                --stack-name "$STACK_NAME" \
                --query "Stacks[0].StackId" \
                --output text 2>/dev/null || echo "NOT_FOUND")
              
              if [ "$STACK_EXISTS" != "NOT_FOUND" ]; then
                DOMAIN_IN_STACK=$(aws cloudformation describe-stack-resources \
                  --stack-name "$STACK_NAME" \
                  --query "StackResources[?LogicalResourceId=='ApiGatewayDomainName'].PhysicalResourceId" \
                  --output text 2>/dev/null || echo "")
                
                if [ -n "$DOMAIN_IN_STACK" ] && [ "$DOMAIN_IN_STACK" = "$CUSTOM_DOMAIN_NAME" ]; then
                  if [ "$ENDPOINT_TYPE" != "REGIONAL" ]; then
                    echo "ERROR: Domain is in CloudFormation stack but has wrong endpoint type ($ENDPOINT_TYPE)."
                    echo "CloudFormation cannot update endpoint type. You must:"
                    echo "1. Delete the domain from AWS Console or CLI"
                    echo "2. Remove the failed resource from the stack, OR delete and recreate the stack"
                    exit 1
                  else
                    echo "Domain is managed by CloudFormation stack with correct endpoint type, will be updated."
                  fi
                else
                  # Domain exists but not in stack
                  if [ "$ENDPOINT_TYPE" != "REGIONAL" ]; then
                    echo "WARNING: Domain exists with $ENDPOINT_TYPE endpoint type, but template requires REGIONAL."
                    echo "AWS API Gateway does not allow changing endpoint type. Cleaning up..."
                    
                    # Delete base path mappings
                    BASE_PATHS=$(aws apigateway get-base-path-mappings \
                      --domain-name "$CUSTOM_DOMAIN_NAME" \
                      --query 'items[*].basePath' \
                      --output text 2>/dev/null || echo "")
                    
                    if [ -n "$BASE_PATHS" ]; then
                      echo "Deleting base path mappings..."
                      for BASE_PATH in $BASE_PATHS; do
                        if [ "$BASE_PATH" = "(none)" ] || [ -z "$BASE_PATH" ]; then
                          BASE_PATH=""
                        fi
                        echo "  Deleting base path mapping: '$BASE_PATH'"
                        aws apigateway delete-base-path-mapping \
                          --domain-name "$CUSTOM_DOMAIN_NAME" \
                          --base-path "$BASE_PATH" 2>/dev/null || true
                      done
                    fi
                    
                    # Delete the domain
                    echo "Deleting existing domain name..."
                    aws apigateway delete-domain-name \
                      --domain-name "$CUSTOM_DOMAIN_NAME" 2>/dev/null || {
                      echo "ERROR: Failed to delete domain automatically. Please delete manually:"
                      echo "  aws apigateway delete-domain-name --domain-name $CUSTOM_DOMAIN_NAME"
                      exit 1
                    }
                    
                    echo "Domain deleted successfully. CloudFormation will create a new one with REGIONAL endpoint."
                    sleep 10  # Wait for AWS to fully propagate the deletion
                  else
                    echo "Domain uses REGIONAL endpoint type, but is not in stack."
                    echo "CloudFormation may fail to import it. Consider deleting it manually first."
                  fi
                fi
              else
                # Stack doesn't exist - check endpoint type
                if [ "$ENDPOINT_TYPE" != "REGIONAL" ]; then
                  echo "WARNING: Domain exists with $ENDPOINT_TYPE endpoint type, but template requires REGIONAL."
                  echo "Cleaning up domain before creating stack..."
                  
                  # Delete base path mappings and domain
                  BASE_PATHS=$(aws apigateway get-base-path-mappings \
                    --domain-name "$CUSTOM_DOMAIN_NAME" \
                    --query 'items[*].basePath' \
                    --output text 2>/dev/null || echo "")
                  
                  if [ -n "$BASE_PATHS" ]; then
                    for BASE_PATH in $BASE_PATHS; do
                      if [ "$BASE_PATH" = "(none)" ] || [ -z "$BASE_PATH" ]; then
                        BASE_PATH=""
                      fi
                      aws apigateway delete-base-path-mapping \
                        --domain-name "$CUSTOM_DOMAIN_NAME" \
                        --base-path "$BASE_PATH" 2>/dev/null || true
                    done
                  fi
                  
                  aws apigateway delete-domain-name \
                    --domain-name "$CUSTOM_DOMAIN_NAME" 2>/dev/null || {
                    echo "ERROR: Failed to delete domain. Please delete manually before deploying."
                    exit 1
                  }
                  
                  echo "Domain deleted. CloudFormation will create it fresh."
                  sleep 10
                else
                  echo "Domain exists with REGIONAL endpoint. CloudFormation will attempt to create/update it."
                fi
              fi
            else
              echo "No existing domain name found, CloudFormation will create a new one."
            fi
          fi

          # Build parameter overrides
          PARAM_OVERRIDES="S3Key=$S3_FILE_NAME S3Bucket=$S3_BUCKET StageName=$STAGE_NAME LambdaFunctionName=$LAMBDA_FUNCTION_NAME ApiGatewayName=$API_GATEWAY_NAME LambdaExecutionRoleName=$LAMBDA_ROLE_NAME"
          
          if [ -n "$CUSTOM_DOMAIN_NAME" ]; then
            PARAM_OVERRIDES="$PARAM_OVERRIDES CustomDomainName=$CUSTOM_DOMAIN_NAME"
          fi
          
          if [ -n "$ACM_CERTIFICATE_ARN" ]; then
            PARAM_OVERRIDES="$PARAM_OVERRIDES AcmCertificateArn=$ACM_CERTIFICATE_ARN"
          fi
          
          if [ -n "$HOSTED_ZONE_ID" ]; then
            PARAM_OVERRIDES="$PARAM_OVERRIDES HostedZoneId=$HOSTED_ZONE_ID"
          fi

          aws cloudformation deploy \
            --stack-name "$STACK_NAME" \
            --template-file deployment.yml \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --parameter-overrides $PARAM_OVERRIDES


